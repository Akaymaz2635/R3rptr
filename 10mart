import customtkinter as ctk
from docx import Document
import docx
from tkinter import filedialog, ttk, Tk, messagebox
import tkinter as tk
import shutil
import os
import sys
import subprocess
import datetime
import logging

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("app.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("IRS_YAZICI")

# Set theme to modern look
ctk.set_appearance_mode("dark")
ctk.set_default_color_theme("blue")

class LotDetailManager:
    """
    A class to manage lot details separately from the main application.
    This creates better separation of concerns and makes the code more maintainable.
    """
    
    def __init__(self, parent):
        """
        Initialize the lot detail manager.
        
        Args:
            parent: The parent application that owns this manager
        """
        self.parent = parent
        self.lot_details = {}
        self.part_quantities = {}
        self.part_numbers = {}
        self.lot_notes = {}
        
    def show_lot_detail_dialog(self, row_idx, item_no, dimension, actual_value, widgets_dict):
        """
        Show the lot detail dialog for a specific item.
        
        Args:
            row_idx (int): The row index in the table
            dimension (str): The dimension value
            item_no (str): The item number
            actual_value (str): The current actual value
            widgets_dict (dict): Dictionary of widgets to update
        """
        # Ensure we have valid values for the key parts
        dimension = dimension if dimension else "Unknown Dimension"
        item_no = item_no if item_no else "Unknown Item"
        key = f"{dimension}_{item_no}"
        
        # Create the dialog window
        detail_window = ctk.CTkToplevel(self.parent)
        detail_window.title(f"Lot Detail - {item_no}")
        detail_window.geometry("500x500")
        detail_window.grab_set()  # Make it modal
        
        # Create the main content frame
        content_frame = ctk.CTkFrame(detail_window, corner_radius=10)
        content_frame.pack(padx=20, pady=20, fill="both", expand=True)
        
        # Add title
        ctk.CTkLabel(content_frame, text=f"Lot Detail for Item: {item_no}", 
                    font=("Helvetica", 18, "bold")).pack(pady=(10, 20))
        
        # Create scrollable frame for content
        main_info_frame = ctk.CTkFrame(content_frame, corner_radius=8)
        main_info_frame.pack(padx=15, pady=10, fill="both", expand=True)
        
        info_scroll = ctk.CTkScrollableFrame(main_info_frame, corner_radius=8)
        info_scroll.pack(fill="both", expand=True)
        
        info_frame = ctk.CTkFrame(info_scroll, corner_radius=0)
        info_frame.pack(fill="both", expand=True)
        
        # Add item information
        ctk.CTkLabel(info_frame, text=f"DIMENSION: {dimension}", 
                    font=("Helvetica", 14)).pack(anchor="w", padx=15, pady=5)
        ctk.CTkLabel(info_frame, text=f"ITEM NO: {item_no}", 
                    font=("Helvetica", 14)).pack(anchor="w", padx=15, pady=5)
        ctk.CTkLabel(info_frame, text=f"ACTUAL Value: {actual_value}", 
                    font=("Helvetica", 14)).pack(anchor="w", padx=15, pady=5)
        ctk.CTkLabel(info_frame, text=f"Row Index: {row_idx}", 
                    font=("Helvetica", 14)).pack(anchor="w", padx=15, pady=5)
        
        # Part quantity section
        quantity_frame = ctk.CTkFrame(info_frame)
        quantity_frame.pack(fill="x", padx=15, pady=5)
        
        ctk.CTkLabel(quantity_frame, text="Part Quantity:", 
                    font=("Helvetica", 14)).pack(side="left", padx=(0, 10))
        
        # Get saved quantity if it exists
        saved_quantity = self.part_quantities.get(key, "0")
        quantity_var = tk.StringVar(value=saved_quantity)
        
        quantity_display = ctk.CTkLabel(quantity_frame, 
                                    textvariable=quantity_var,
                                    font=("Helvetica", 14, "bold"))
        quantity_display.pack(side="left", padx=10)
        
        # Parts list frame
        parts_scroll = ctk.CTkScrollableFrame(info_frame, corner_radius=6, height=150)
        parts_scroll.pack(fill="x", padx=15, pady=10)
        
        parts_frame = ctk.CTkFrame(parts_scroll, corner_radius=0)
        parts_frame.pack(fill="both", expand=True)
        
        # Get saved part numbers
        saved_part_numbers = self.part_numbers.get(key, {})
        part_entries = {}  # Will store the entry widgets
        
        # Function to update the part entries based on quantity
        def update_part_entries():
            # Clear existing entries
            for widget in parts_frame.winfo_children():
                widget.destroy()
                
            quantity = int(quantity_var.get())
            
            if quantity > 0:
                ctk.CTkLabel(parts_frame, text="Part Numbers:", 
                            font=("Helvetica", 14, "bold")).pack(anchor="w", pady=(0, 5))
            
            for i in range(1, quantity + 1):
                entry_frame = ctk.CTkFrame(parts_frame)
                entry_frame.pack(fill="x", pady=2)
                
                ctk.CTkLabel(entry_frame, text=f"{i}-", 
                            font=("Helvetica", 12)).pack(side="left", padx=(0, 5))
                
                entry = ctk.CTkEntry(entry_frame, width=200, height=30, corner_radius=6, 
                                    font=("Helvetica", 12))
                entry.pack(side="left", fill="x", expand=True)
                
                # Load saved value if available
                if str(i) in saved_part_numbers:
                    entry.insert(0, saved_part_numbers[str(i)])
                
                part_entries[i] = entry
        
        # Create increase/decrease buttons for quantity
        def increase_quantity():
            current = int(quantity_var.get())
            quantity_var.set(str(current + 1))
            update_part_entries()
            
        increase_btn = ctk.CTkButton(quantity_frame, text="Increase", 
                                    font=("Helvetica", 12),
                                    width=80, height=25, corner_radius=6,
                                    command=increase_quantity)
        increase_btn.pack(side="left", padx=5)
        
        def decrease_quantity():
            current = int(quantity_var.get())
            if current > 0:  # Prevent negative values
                quantity_var.set(str(current - 1))
                update_part_entries()
        
        decrease_btn = ctk.CTkButton(quantity_frame, text="Decrease", 
                                    font=("Helvetica", 12),
                                    width=80, height=25, corner_radius=6,
                                    command=decrease_quantity)
        decrease_btn.pack(side="left", padx=5)
        
        # Initialize part entries
        update_part_entries()
        
        # Notes section
        ctk.CTkLabel(info_frame, text="Additional Notes:", 
                    font=("Helvetica", 14)).pack(anchor="w", padx=15, pady=(15, 5))
        
        notes_frame = ctk.CTkFrame(info_frame)
        notes_frame.pack(padx=15, pady=5, fill="x")
        
        notes_entry = ctk.CTkTextbox(notes_frame, height=100, corner_radius=6)
        notes_entry.pack(side="left", fill="both", expand=True)
        
        # Load saved notes if available
        saved_notes = self.lot_notes.get(key, "")
        if saved_notes:
            notes_entry.insert("1.0", saved_notes)
        
        scrollbar = ctk.CTkScrollbar(notes_frame, command=notes_entry.yview)
        scrollbar.pack(side="right", fill="y")
        notes_entry.configure(yscrollcommand=scrollbar.set)
        
        # Function to save the data
        def save_lot_data():
            # Get notes
            notes_text = notes_entry.get("1.0", "end").strip()
            
            # Get part numbers
            current_part_numbers = {}
            for i, entry in part_entries.items():
                current_part_numbers[str(i)] = entry.get()
            
            # Calculate min and max values for ACTUAL
            valid_numbers = self._extract_numeric_values(current_part_numbers)
            
            if valid_numbers:
                min_value = min(valid_numbers)
                max_value = max(valid_numbers)
                min_max_str = f"{min_value} / {max_value}"
                
                # Update widgets and values
                if key in widgets_dict:
                    widgets_dict[key].delete(0, "end")
                    widgets_dict[key].insert(0, min_max_str)
                
                # Update the parent's actual_values dictionary
                self.parent.actual_values[key] = min_max_str
            
            # Save all lot details
            self.part_quantities[key] = quantity_var.get()
            self.part_numbers[key] = current_part_numbers
            self.lot_notes[key] = notes_text
            
            logger.info(f"Saved lot details for {key}")
            
            # Close the dialog
            detail_window.destroy()
        
        # Add save and close buttons
        button_frame = ctk.CTkFrame(content_frame)
        button_frame.pack(pady=15)
        
        ctk.CTkButton(button_frame, text="Save", font=("Helvetica", 14), 
                     width=100, height=30, corner_radius=6, 
                     command=save_lot_data).pack(side="left", padx=10)
        
        ctk.CTkButton(button_frame, text="Close", font=("Helvetica", 14), 
                     width=100, height=30, corner_radius=6, 
                     command=detail_window.destroy).pack(side="left", padx=10)
    
    def _extract_numeric_values(self, part_numbers):
        """
        Extract numeric values from part numbers, handling various formats.
        
        Args:
            part_numbers (dict): Dictionary of part numbers
            
        Returns:
            list: List of valid numeric values
        """
        valid_numbers = []
        
        for num_str in part_numbers.values():
            if not num_str or not num_str.strip():
                continue
                
            # Handle slash-separated values
            if '/' in num_str:
                parts = num_str.split('/')
                for part in parts:
                    try:
                        if part and part.strip():
                            valid_numbers.append(float(part.strip()))
                    except ValueError:
                        continue
            else:
                # Handle single values
                try:
                    valid_numbers.append(float(num_str))
                except ValueError:
                    continue
        
        return valid_numbers
    
    def export_lot_details_to_text(self, folder_path, project_info):
        """
        Export lot details to a text file.
        
        Args:
            folder_path (str): Path to save the file
            project_info (dict): Project information for the header
            
        Returns:
            str: Path to the created file
            list: Content lines of the lot details
        """
        lot_details_file = os.path.join(folder_path, "lot_details.txt")
        lot_details_content = []
        
        # Add project info header
        for key, value in project_info.items():
            lot_details_content.append(f"{key}: {value}")
        
        lot_details_content.append("")
        lot_details_content.append("LOT DETAYLARI:")
        lot_details_content.append("=" * 40)
        lot_details_content.append("")
        
        # Add lot details
        has_details = False
        for key in self.part_quantities.keys():
            has_details = True
            actual_value = self.parent.actual_values.get(key, "")
            
            lot_details_content.append(f"{key}")
            lot_details_content.append(f"ACTUAL Değeri: {actual_value}")
            
            # Part quantity
            quantity = self.part_quantities.get(key, "0")
            lot_details_content.append(f"Parça Miktarı: {quantity}")
            
            # Part numbers
            part_numbers = self.part_numbers.get(key, {})
            if part_numbers:
                lot_details_content.append("Parça Numaraları:")
                for part_idx, part_num in part_numbers.items():
                    if part_num and part_num.strip():
                        lot_details_content.append(f"{part_idx}- {part_num}")
            
            # Notes
            notes = self.lot_notes.get(key, "")
            if notes:
                lot_details_content.append("Notlar:")
                lot_details_content.append(f"{notes}")
            
            lot_details_content.append("")
            lot_details_content.append("-" * 40)
            lot_details_content.append("")
        
        # Write to file if we have details
        if has_details:
            try:
                with open(lot_details_file, "w", encoding="utf-8") as f:
                    for line in lot_details_content:
                        f.write(f"{line}\n")
                logger.info(f"Lot details exported to: {lot_details_file}")
                return lot_details_file, lot_details_content
            except Exception as e:
                logger.error(f"Error saving lot details: {str(e)}")
                return None, lot_details_content
        
        return None, lot_details_content

    def add_lot_details_to_word(self, doc, lot_details_content):
        """
        Add lot details to a Word document
        
        Args:
            doc: The Word document object
            lot_details_content: List of content lines
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            # Add page break before lot details
            doc.add_paragraph().runs[0].add_break(docx.enum.text.WD_BREAK.PAGE)
            
            # Add title
            p = doc.add_paragraph()
            p.add_run("LOT DETAYLARI").bold = True
            p.style = 'Heading 1'
            p.alignment = docx.enum.text.WD_ALIGN_PARAGRAPH.CENTER
            
            # Add content
            for line in lot_details_content:
                if line.startswith("="):
                    # Separator lines
                    p = doc.add_paragraph()
                    run = p.add_run(line)
                    run.bold = True
                elif line.startswith("-"):
                    # Sub-separator lines
                    p = doc.add_paragraph()
                    p.add_run(line)
                elif line.startswith("LOT DETAYLARI:"):
                    # Main title already added, skip
                    continue
                elif not line:
                    # Empty line
                    doc.add_paragraph()
                elif any(line.startswith(prefix) for prefix in ["Proje Tipi:", "Parça Numarası:", "Operasyon No:", "Seri No:", "Oluşturma Tarihi:"]):
                    # Project info
                    p = doc.add_paragraph()
                    run = p.add_run(line)
                    run.bold = True
                elif line.count("_") > 0 and not line.startswith(" "):
                    # Key line (e.g., "6.3 RA_KN998")
                    p = doc.add_paragraph()
                    run = p.add_run(line)
                    run.bold = True
                    run.font.size = docx.shared.Pt(12)
                else:
                    # Normal content
                    doc.add_paragraph(line)
            
            # Add page break at end
            doc.add_paragraph().runs[0].add_break(docx.enum.text.WD_BREAK.PAGE)
            
            logger.info("Added lot details to Word document")
            return True
        except Exception as e:
            logger.error(f"Error adding lot details to Word: {str(e)}")
            return False


class ProjectManager:
    """
    Manages project structure, folders, and files
    """
    def __init__(self):
        self.project_info = {}
        self.serial_folder = None
    
    def create_project_structure(self, project_type, part_number, operation_number, serial_number, continue_measurement):
        """
        Create the project folder structure and info file
        
        Args:
            project_type (str): Project type
            part_number (str): Part number
            operation_number (str): Operation number
            serial_number (str): Serial number
            continue_measurement (bool): Whether to continue measurement
            
        Returns:
            tuple: (success, folder_path, error_message)
        """
        try:
            # Validate inputs
            if not project_type or not part_number or not operation_number or not serial_number:
                return False, None, "All fields must be filled"
            
            # Store project info
            self.project_info = {
                "Proje Tipi": project_type,
                "Parça Numarası": part_number,
                "Operasyon No": operation_number,
                "Seri No": serial_number,
                "Yarım Kalan Ölçüm": 'Evet' if continue_measurement else 'Hayır',
                "Oluşturma Tarihi": datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            }
            
            # Get desktop path
            desktop_path = os.path.join(os.path.expanduser("~"), "Desktop")
            
            # Create folder structure
            report_folder = os.path.join(desktop_path, "Report")
            if not os.path.exists(report_folder):
                os.makedirs(report_folder)
            
            project_type_folder = os.path.join(report_folder, project_type)
            if not os.path.exists(project_type_folder):
                os.makedirs(project_type_folder)
            
            part_number_folder = os.path.join(project_type_folder, part_number)
            if not os.path.exists(part_number_folder):
                os.makedirs(part_number_folder)
            
            operation_folder = os.path.join(part_number_folder, operation_number)
            if not os.path.exists(operation_folder):
                os.makedirs(operation_folder)
            
            serial_folder = os.path.join(operation_folder, serial_number)
            if not os.path.exists(serial_folder):
                os.makedirs(serial_folder)
            
            # Store serial folder for future use
            self.serial_folder = serial_folder
            
            # Create info file
            info_file_path = os.path.join(serial_folder, "info.txt")
            with open(info_file_path, "w") as f:
                for key, value in self.project_info.items():
                    f.write(f"{key}: {value}\n")
            
            logger.info(f"Project structure created at: {serial_folder}")
            return True, serial_folder, None
            
        except Exception as e:
            logger.error(f"Error creating project structure: {str(e)}")
            return False, None, str(e)
    
    def open_folder(self, folder_path):
        """Open folder in file explorer"""
        try:
            if os.name == 'nt':  # Windows
                os.startfile(folder_path)
            elif os.name == 'posix':  # macOS, Linux
                if sys.platform == 'darwin':  # macOS
                    subprocess.call(['open', folder_path])
                else:  # Linux
                    subprocess.call(['xdg-open', folder_path])
            logger.info(f"Opened folder: {folder_path}")
            return True
        except Exception as e:
            logger.error(f"Error opening folder: {str(e)}")
            return False


class TableReader:
    """
    Reads and processes tables from Word documents
    """
    def __init__(self):
        self.table_data = []
        self.table_has_actual = []
    
    def read_word_tables(self, docx_path):
        """
        Read tables from a Word document
        
        Args:
            docx_path (str): Path to the Word document
            
        Returns:
            list: List of tables
        """
        try:
            doc = Document(docx_path)
            table_data = []
            table_has_actual = []
            
            for table in doc.tables:
                processed_table = self._process_table(table)
                if processed_table:  # Only add non-empty tables
                    # Extract the has_actual_column flag
                    has_actual = processed_table[-1].get("has_actual_column", False)
                    processed_table.pop()  # Remove the metadata
                    
                    table_data.append(processed_table)
                    table_has_actual.append(has_actual)
            
            self.table_data = table_data
            self.table_has_actual = table_has_actual
            logger.info(f"Read {len(table_data)} tables from {docx_path}")
            return table_data
        except Exception as e:
            logger.error(f"Error reading Word document: {str(e)}")
            raise
    
    def _process_table(self, table):
        """
        Process a single table, removing RECORDING SHEET rows and adjusting headers
        
        Args:
            table: Word table object
            
        Returns:
            list: Processed table data or None if table should be skipped
        """
        table_data = []
        has_actual_column = False
        
        # Extract rows, skipping RECORDING SHEET
        for row in table.rows:
            row_data = [cell.text.strip() for cell in row.cells]
            
            # Skip empty rows
            if not any(row_data):
                continue
            
            # Check if this is a RECORDING SHEET row
            row_text = " ".join(row_data).upper()
            if any(pattern in row_text for pattern in ["RECORDIG SHEET", "RECORDING SHEET", "REC ORDIG SHEET"]):
                continue
            
            # Check if row might contain ACTUAL column
            if "ACTUAL" in row_text:
                has_actual_column = True
                
            # Add valid row
            table_data.append(row_data)
        
        # Skip empty tables
        if not table_data:
            return None
        
        # Check if headers need adjustment
        if len(table_data) >= 2:
            first_row = table_data[0]
            second_row = table_data[1]
            
            # Check if ACTUAL is in the rows
            has_actual_first = any("ACTUAL" in cell.upper() for cell in first_row if cell)
            has_actual_second = any("ACTUAL" in cell.upper() for cell in second_row if cell)
            
            # If first row doesn't have ACTUAL but second does, skip first row
            if not has_actual_first and has_actual_second:
                logger.info("First row doesn't have ACTUAL, using second row as header")
                table_data = table_data[1:]
                has_actual_column = True
        
        # If we've processed the whole table and still haven't found an ACTUAL column,
        # check the first row (which should be headers) one more time
        if not has_actual_column and table_data:
            first_row = table_data[0]
            has_actual_column = any("ACTUAL" in cell.upper() for cell in first_row if cell)
        
        # Store whether this table has an ACTUAL column
        table_data.append({"has_actual_column": has_actual_column})
        
        return table_data
    
    def get_column_indices(self, headers):
        """
        Find important column indices in the headers
        
        Args:
            headers (list): List of header strings
            
        Returns:
            dict: Dictionary of column indices
        """
        indices = {
            'actual': -1,
            'item_no': -1,
            'dimension': -1,
            'badge': -1,
            'tooling': -1,
            'insp_level': -1
        }
        
        for idx, header in enumerate(headers):
            header_upper = header.strip().upper()
            
            if "ACTUAL" in header_upper:
                indices['actual'] = idx
            if "ITEM NO" in header_upper or "ITEMNO" in header_upper:
                indices['item_no'] = idx
            if "DIMENSION" in header_upper or "DIM" in header_upper:
                indices['dimension'] = idx
            if "BADGE" in header_upper:
                indices['badge'] = idx
            if "TOOLING" in header_upper:
                indices['tooling'] = idx
            if "INSP. LEVEL" in header_upper or "INSPLEVEL" in header_upper:
                indices['insp_level'] = idx
        
        logger.info(f"Column indices: {indices}")
        return indices


class ReportGenerator:
    """
    Generates reports by updating Word documents with ACTUAL values
    """
    def __init__(self, project_manager):
        self.project_manager = project_manager
    
    def create_report(self, source_file, table_index, actual_values, col_indices, lot_detail_manager=None):
        """
        Create a report by copying and updating a Word document
        
        Args:
            source_file (str): Source Word document path
            table_index (int): Index of the table to update
            actual_values (dict): Dictionary of actual values
            col_indices (dict): Dictionary of column indices
            lot_detail_manager (LotDetailManager): Lot detail manager for adding lot details
            
        Returns:
            tuple: (success, file_path, message)
        """
        try:
            # Validate serial folder
            if not self.project_manager.serial_folder:
                return False, None, "Project folder not created"
            
            # Create new file name
            file_name = f"{self.project_manager.project_info['Seri No']}_{os.path.basename(source_file)}"
            output_file = os.path.join(self.project_manager.serial_folder, file_name)
            
            # Copy the file
            shutil.copy2(source_file, output_file)
            
            # Open the copied document
            doc = Document(output_file)
            
            # Ensure table exists
            if table_index >= len(doc.tables):
                return False, None, f"Table index {table_index} out of range"
            
            # Get the table
            table = doc.tables[table_index]
            
            # Find the header row
            header_row_idx = self._find_header_row(table)
            if header_row_idx == -1:
                return False, None, "Header row not found"
            
            # Update ACTUAL values
            updated_count = self._update_actual_values(
                table, 
                header_row_idx, 
                actual_values, 
                col_indices
            )
            
            # Add lot details if available
            lot_details_file = None
            lot_details_content = []
            
            if lot_detail_manager and hasattr(lot_detail_manager, 'part_quantities') and lot_detail_manager.part_quantities:
                # Export lot details to text
                lot_details_file, lot_details_content = lot_detail_manager.export_lot_details_to_text(
                    self.project_manager.serial_folder,
                    self.project_manager.project_info
                )
                
                # Add lot details to Word document
                if lot_details_content:
                    lot_detail_manager.add_lot_details_to_word(doc, lot_details_content)
            
            # Save the document
            doc.save(output_file)
            
            # Create success message
            message = f"Report saved to: {output_file}\n" + \
                     f"Updated rows: {updated_count}"
            
            if lot_details_file:
                message += f"\nLot details: {lot_details_file}"
            
            logger.info(f"Report created: {output_file}")
            return True, output_file, message
            
        except Exception as e:
            logger.error(f"Error creating report: {str(e)}")
            return False, None, f"Error: {str(e)}"
    
    def _find_header_row(self, table):
        """
        Find the header row in the table
        
        Args:
            table: Word table object
            
        Returns:
            int: Header row index or -1 if not found
        """
        for i, row in enumerate(table.rows):
            # Get text from all cells
            row_text = " ".join([cell.text.strip().upper() for cell in row.cells])
            
            # Skip RECORDING SHEET rows
            if any(pattern in row_text for pattern in ["RECORDIG SHEET", "RECORDING SHEET", "REC ORDIG SHEET"]):
                continue
            
            # Look for header indicators
            if ("ITEM" in row_text and "NO" in row_text) and "DIMENSION" in row_text and "ACTUAL" in row_text:
                return i
        
        # If not found, check first few rows for ACTUAL
        for i in range(min(3, len(table.rows))):
            header_cells = [cell.text.strip().upper() for cell in table.rows[i].cells]
            if any("ACTUAL" in cell for cell in header_cells):
                return i
        
        return -1
    
    def _update_actual_values(self, table, header_row_idx, actual_values, col_indices):
        """
        Update ACTUAL values in the table
        
        Args:
            table: Word table object
            header_row_idx (int): Header row index
            actual_values (dict): Dictionary of actual values
            col_indices (dict): Dictionary of column indices
            
        Returns:
            int: Number of updated rows
        """
        updated_count = 0
        
        # Get column indices from indices dict
        actual_col_idx = col_indices['actual']
        item_no_col_idx = col_indices['item_no']
        dimension_col_idx = col_indices['dimension']
        
        # Make sure we have the required columns
        if actual_col_idx == -1 or item_no_col_idx == -1 or dimension_col_idx == -1:
            logger.error("Required columns not found")
            return 0
        
        # Update values
        for i, row in enumerate(table.rows):
            # Skip header row and anything before it
            if i <= header_row_idx:
                continue
            
            # Check column indices are within range
            if (item_no_col_idx >= len(row.cells) or 
                dimension_col_idx >= len(row.cells) or 
                actual_col_idx >= len(row.cells)):
                continue
            
            # Get cell values
            item_no = row.cells[item_no_col_idx].text.strip()
            dimension = row.cells[dimension_col_idx].text.strip()
            
            # Skip if item_no or dimension is empty
            if not item_no or not dimension:
                continue
            
            # Create key
            key = f"{dimension}_{item_no}"
            
            # Check if we have a value for this key
            if key in actual_values and actual_values[key]:
                actual_value = str(actual_values[key])
                
                # Update the cell
                row.cells[actual_col_idx].text = actual_value
                updated_count += 1
                logger.debug(f"Updated {key} with {actual_value}")
        
        return updated_count


class TableViewer(ctk.CTk):
    """
    Main application class for viewing and editing table data
    """
    def __init__(self):
        super().__init__()
        
        # Initialize app components
        self.title("Tam Tablo Görüntüleyici - ACTUAL ile EntryBox")
        self.geometry("1200x900")
        
        # Initialize managers
        self.project_manager = ProjectManager()
        self.table_reader = TableReader()
        self.lot_detail_manager = LotDetailManager(self)
        self.report_generator = ReportGenerator(self.project_manager)
        
        # Initialize data
        self.actual_values = {}  # Store ACTUAL values
        self.widgets = {}  # Store UI widgets
        self.selected_table_idx = 0
        self.selected_file_path = None
        self.headers = []
        self.col_indices = {}
        
        # Set up UI
        self._setup_ui()
    
    def _setup_ui(self):
        """Set up the user interface with TabView"""
        # Main frame
        self.main_frame = ctk.CTkFrame(self, corner_radius=10)
        self.main_frame.pack(padx=30, pady=30, fill="both", expand=True)
        
        # Main title
        self.title_label = ctk.CTkLabel(
            self.main_frame, 
            text="Ölçüm Rapor Sistemi", 
            font=("Helvetica", 24, "bold")
        )
        self.title_label.pack(pady=(0, 20))
        
        # Create TabView
        self.tabview = ctk.CTkTabview(self.main_frame)
        self.tabview.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Add tabs
        self.tab_project = self.tabview.add("Proje Bilgileri")
        self.tab_table = self.tabview.add("Tablo Görüntüleme")
        self.tab_report = self.tabview.add("Rapor Oluşturma")
        
        # Set default tab
        self.tabview.set("Proje Bilgileri")
        
        # Setup each tab
        self._setup_project_tab()
        self._setup_table_tab()
        self._setup_report_tab()
    
    def _setup_project_tab(self):
        """Set up the project information tab"""
        # Project info frame
        self.info_frame = ctk.CTkFrame(self.tab_project, corner_radius=8)
        self.info_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        # Title
        ctk.CTkLabel(
            self.info_frame, 
            text="Proje Bilgileri", 
            font=("Helvetica", 20, "bold")
        ).pack(pady=(20, 30))
        
        # Create grid frame for inputs
        input_frame = ctk.CTkFrame(self.info_frame, corner_radius=0)
        input_frame.pack(fill="x", padx=40, pady=10)
        
        # Project type
        ctk.CTkLabel(input_frame, text="Proje Tipi:", font=("Helvetica", 14)).grid(
            row=0, column=0, padx=10, pady=15, sticky="e"
        )
        self.project_type = ctk.CTkComboBox(
            input_frame, 
            values=["Tip A", "Tip B", "Tip C"], 
            font=("Helvetica", 14), 
            width=250
        )
        self.project_type.grid(row=0, column=1, padx=10, pady=15, sticky="w")
        
        # Part number
        ctk.CTkLabel(input_frame, text="Parça Numarası:", font=("Helvetica", 14)).grid(
            row=1, column=0, padx=10, pady=15, sticky="e"
        )
        self.part_number = ctk.CTkEntry(input_frame, font=("Helvetica", 14), width=250)
        self.part_number.grid(row=1, column=1, padx=10, pady=15, sticky="w")
        
        # Operation number
        ctk.CTkLabel(input_frame, text="Operasyon No:", font=("Helvetica", 14)).grid(
            row=2, column=0, padx=10, pady=15, sticky="e"
        )
        self.operation_number = ctk.CTkEntry(input_frame, font=("Helvetica", 14), width=250)
        self.operation_number.grid(row=2, column=1, padx=10, pady=15, sticky="w")
        
        # Serial number
        ctk.CTkLabel(input_frame, text="Seri No:", font=("Helvetica", 14)).grid(
            row=3, column=0, padx=10, pady=15, sticky="e"
        )
        self.serial_number = ctk.CTkEntry(input_frame, font=("Helvetica", 14), width=250)
        self.serial_number.grid(row=3, column=1, padx=10, pady=15, sticky="w")
        
        # Continue measurement checkbox
        self.continue_measurement = ctk.CTkCheckBox(
            input_frame, 
            text="Yarım Kalan Ölçüme Devam Et", 
            font=("Helvetica", 14)
        )
        self.continue_measurement.grid(row=4, column=0, columnspan=2, padx=10, pady=20)
        
        # Configure grid columns
        input_frame.grid_columnconfigure(0, weight=1)
        input_frame.grid_columnconfigure(1, weight=1)
        
        # File selection section - MOVED FROM TABLE TAB TO PROJECT TAB
        file_frame = ctk.CTkFrame(self.info_frame, corner_radius=0)
        file_frame.pack(fill="x", padx=40, pady=10)
        
        # File selection title
        ctk.CTkLabel(
            file_frame, 
            text="Dosya Seçimi", 
            font=("Helvetica", 16, "bold")
        ).pack(pady=(10, 15))
        
        # File selection button
        self.select_button = ctk.CTkButton(
            file_frame, 
            text="Word Dosyası Seç", 
            font=("Helvetica", 16),
            width=200, 
            height=40, 
            corner_radius=8,
            command=self.select_file
        )
        self.select_button.pack(pady=15)
        
        # File path display
        self.file_path_var = tk.StringVar(value="Henüz dosya seçilmedi")
        ctk.CTkLabel(
            file_frame, 
            textvariable=self.file_path_var,
            font=("Helvetica", 12, "italic")
        ).pack(pady=(0, 15))
        
        # Button frame
        button_frame = ctk.CTkFrame(self.info_frame, corner_radius=0)
        button_frame.pack(fill="x", padx=40, pady=(20, 40))
        
        # Save button
        self.save_info_button = ctk.CTkButton(
            button_frame, 
            text="Bilgileri Kaydet", 
            font=("Helvetica", 16),
            width=200, 
            height=40, 
            corner_radius=8,
            command=self.save_project_info
        )
        self.save_info_button.pack(pady=10)
        
        # Next tab button
        self.next_tab_button = ctk.CTkButton(
            button_frame, 
            text="Tablo Görüntülemeye Geç", 
            font=("Helvetica", 16),
            width=250, 
            height=40, 
            corner_radius=8,
            command=lambda: self.tabview.set("Tablo Görüntüleme")
        )
        self.next_tab_button.pack(pady=10)

    def _setup_table_tab(self):
        """Set up the table viewing tab"""
        # Table frame
        self.table_content_frame = ctk.CTkFrame(self.tab_table, corner_radius=8)
        self.table_content_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        # Title
        ctk.CTkLabel(
            self.table_content_frame, 
            text="Tablo Görüntüleme", 
            font=("Helvetica", 20, "bold")
        ).pack(pady=(20, 30))
        
        # Table selector frame
        self.table_selector_frame = ctk.CTkFrame(self.table_content_frame, corner_radius=0)
        self.table_selector_frame.pack(fill="x", padx=40, pady=10)
        
        # Table selector label
        ctk.CTkLabel(
            self.table_selector_frame,
            text="Tablo Seçiniz:",
            font=("Helvetica", 14)
        ).pack(side="left", padx=(0, 10))
        
        # Table selector
        self.table_selector = ctk.CTkComboBox(
            self.table_selector_frame, 
            values=[], 
            font=("Helvetica", 14),
            width=200, 
            height=30, 
            corner_radius=6,
            command=self.on_table_select
        )
        self.table_selector.pack(side="left", padx=10)
        
        # Hide initially
        self.table_selector_frame.pack_forget()
        
        # Create a frame for the table content
        self.table_display_frame = ctk.CTkFrame(self.table_content_frame, corner_radius=8)
        self.table_display_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        # Initial message
        self.table_initial_message = ctk.CTkLabel(
            self.table_display_frame,
            text="Lütfen önce bir Word dosyası seçiniz.",
            font=("Helvetica", 16)
        )
        self.table_initial_message.pack(pady=50)
        
        # Navigation buttons
        nav_frame = ctk.CTkFrame(self.table_content_frame, corner_radius=0)
        nav_frame.pack(fill="x", padx=40, pady=(10, 20))
        
        # Back to project button
        ctk.CTkButton(
            nav_frame, 
            text="Proje Bilgilerine Dön", 
            font=("Helvetica", 14),
            width=180, 
            height=35, 
            corner_radius=8,
            command=lambda: self.tabview.set("Proje Bilgileri")
        ).pack(side="left", padx=10)
        
        # Go to report button
        ctk.CTkButton(
            nav_frame, 
            text="Rapor Oluşturmaya Geç", 
            font=("Helvetica", 14),
            width=180, 
            height=35, 
            corner_radius=8,
            command=lambda: self.tabview.set("Rapor Oluşturma")
        ).pack(side="right", padx=10)
